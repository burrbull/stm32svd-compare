<registers>
        <register>
          <name>POWER</name>
          <displayName>POWER</displayName>
          <description>SDMMC power control register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DIRPOL</name>
              <description>Data and command direction signals
              polarity selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSWITCHEN</name>
              <description>Voltage switch procedure enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSWITCH</name>
              <description>Voltage switch sequence start</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWRCTRL</name>
              <description>SDMMC state control bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKCR</name>
          <displayName>CLKCR</displayName>
          <description>SDI clock control register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SELCLKRX</name>
              <description>Receive clock selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUSSPEED</name>
              <description>Bus speed mode selection between DS, HS,
              SDR12, SDR25 and SDR50, DDR50, SDR104</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DDR</name>
              <description>Data rate signaling selection</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWFC_EN</name>
              <description>Hardware flow control enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NEGEDGE</name>
              <description>SDMMC_CK dephasing selection bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDBUS</name>
              <description>Wide bus mode enable bit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PWRSAV</name>
              <description>Power saving configuration bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLKDIV</name>
              <description>Clock divide factor</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARGR</name>
          <displayName>ARGR</displayName>
          <description>argument register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CMDARG</name>
              <description>Command argument</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR</name>
          <displayName>CMDR</displayName>
          <description>command register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CMDSUSPEND</name>
              <description>The CPSM treats the command as a Suspend
              or Resume command and signals interrupt period
              start/end. This bit can only be written by firmware
              when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1
              and CMDTRANS = 0 Suspend command, start interrupt
              period when response bit BS=0. CMDSUSPEND = 1 and
              CMDTRANS = 1 Resume command with data, end interrupt
              period when response bit DF=1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BOOTEN</name>
              <description>Enable boot mode
              procedure.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BOOTMODE</name>
              <description>Select the boot mode procedure to be
              used. This bit can only be written by firmware when
              CPSM is disabled (CPSMEN = 0)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTHOLD</name>
              <description>Hold new data block transmission and
              reception in the DPSM. If this bit is set, the DPSM
              will not move from the Wait_S state to the Send state
              or from the Wait_R state to the Receive
              state.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CPSMEN</name>
              <description>Command path state machine (CPSM) Enable
              bit This bit is written 1 by firmware, and cleared by
              hardware when the CPSM enters the Idle state. If this
              bit is set, the CPSM is enabled. When DTEN = 1, no
              command will be transfered nor boot procedure will be
              started. CPSMEN is cleared to 0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAITPEND</name>
              <description>CPSM Waits for end of data transfer
              (CmdPend internal signal) from DPSM. This bit when
              set, the CPSM waits for the end of data transfer
              trigger before it starts sending a command. WAITPEND
              is only taken into account when DTMODE = MMC stream
              data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT
              = 1 and DTDIR = from host to card.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAITINT</name>
              <description>CPSM waits for interrupt request. If
              this bit is set, the CPSM disables command timeout
              and waits for an card interrupt request (Response).
              If this bit is cleared in the CPSM Wait state, will
              cause the abort of the interrupt mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAITRESP</name>
              <description>Wait for response bits. This bit can
              only be written by firmware when CPSM is disabled
              (CPSMEN = 0). They are used to configure whether the
              CPSM is to wait for a response, and if yes, which
              kind of response.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMDSTOP</name>
              <description>The CPSM treats the command as a Stop
              Transmission command and signals Abort to the DPSM.
              This bit can only be written by firmware when CPSM is
              disabled (CPSMEN = 0). If this bit is set, the CPSM
              issues the Abort signal to the DPSM when the command
              is sent.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDTRANS</name>
              <description>The CPSM treats the command as a data
              transfer command, stops the interrupt period, and
              signals DataEnable to the DPSM This bit can only be
              written by firmware when CPSM is disabled (CPSMEN =
              0). If this bit is set, the CPSM issues an end of
              interrupt period and issues DataEnable signal to the
              DPSM when the command is sent.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDINDEX</name>
              <description>Command index. This bit can only be
              written by firmware when CPSM is disabled (CPSMEN =
              0). The command index is sent to the card as part of
              a command message.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESP%sR</name>
          <displayName>RESPxR</displayName>
          <dim>4</dim>
          <dimIndex>1-4</dimIndex>
          <dimIncrement>0x4</dimIncrement>
          <description>The RESPxR registers contain the
          status of a card, which is part of the received
          response.</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CARDSTATUS</name>
              <description>see Table404.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTIMER</name>
          <displayName>SDMMC_DTIMER</displayName>
          <description>The SDMMC_DTIMER register contains the data
          timeout period, in card bus clock periods. A counter
          loads the value from the SDMMC_DTIMER register, and
          starts decrementing when the data path state machine
          (DPSM) enters the Wait_R or Busy state. If the timer
          reaches 0 while the DPSM is in either of these states,
          the timeout status flag is set.</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATATIME</name>
              <description>Data and R1b busy timeout period This
              bit can only be written when the CPSM and DPSM are
              not active (CPSMACT = 0 and DPSMACT = 0). Data and
              R1b busy timeout period expressed in card bus clock
              periods.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLENR</name>
          <displayName>SDMMC_DLENR</displayName>
          <description>The SDMMC_DLENR register contains the number
          of data bytes to be transferred. The value is loaded into
          the data counter when data transfer starts.</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATALENGTH</name>
              <description>Data length value This register can only
              be written by firmware when DPSM is inactive (DPSMACT
              = 0). Number of data bytes to be transferred. When
              DDR = 1 DATALENGTH is truncated to a multiple of 2.
              (The last odd byte is not transfered) When DATALENGTH
              = 0 no data will be transfered, when requested by a
              CPSMEN and CMDTRANS = 1 also no command will be
              transfered. DTEN and CPSMEN are cleared to
              0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCTRL</name>
          <displayName>SDMMC_DCTRL</displayName>
          <description>The SDMMC_DCTRL register control the data
          path state machine (DPSM).</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIFORST</name>
              <description>FIFO reset, will flush any remaining
              data. This bit can only be written by firmware when
              IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit
              will only take effect when a transfer error or
              transfer hold occurs.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BOOTACKEN</name>
              <description>Enable the reception of the boot
              acknowledgment. This bit can only be written by
              firmware when DPSM is inactive (DPSMACT =
              0).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIOEN</name>
              <description>SD I/O interrupt enable functions This
              bit can only be written by firmware when DPSM is
              inactive (DPSMACT = 0). If this bit is set, the DPSM
              enables the SD I/O card specific interrupt
              operation.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWMOD</name>
              <description>Read wait mode. This bit can only be
              written by firmware when DPSM is inactive (DPSMACT =
              0).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWSTOP</name>
              <description>Read wait stop This bit is written by
              firmware and auto cleared by hardware when the DPSM
              moves from the READ_WAIT state to the WAIT_R or IDLE
              state.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWSTART</name>
              <description>Read wait start. If this bit is set,
              read wait operation starts.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBLOCKSIZE</name>
              <description>Data block size This bit can only be
              written by firmware when DPSM is inactive (DPSMACT =
              0). Define the data block length when the block data
              transfer mode is selected: When DATALENGTH is not a
              multiple of DBLOCKSIZE, the transfered data is
              truncated at a multiple of DBLOCKSIZE. (Any remain
              data will not be transfered.) When DDR = 1,
              DBLOCKSIZE = 0000 shall not be used. (No data will be
              transfered)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTMODE</name>
              <description>Data transfer mode selection. This bit
              can only be written by firmware when DPSM is inactive
              (DPSMACT = 0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DTDIR</name>
              <description>Data transfer direction selection This
              bit can only be written by firmware when DPSM is
              inactive (DPSMACT = 0).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTEN</name>
              <description>Data transfer enable bit This bit can
              only be written by firmware when DPSM is inactive
              (DPSMACT = 0). This bit is cleared by Hardware when
              data transfer completes. This bit shall only be used
              to transfer data when no associated data transfer
              command is used, i.e. shall not be used with SD or
              eMMC cards.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCNTR</name>
          <displayName>SDMMC_DCNTR</displayName>
          <description>The SDMMC_DCNTR register loads the value
          from the data length register (see SDMMC_DLENR) when the
          DPSM moves from the Idle state to the Wait_R or Wait_S
          state. As data is transferred, the counter decrements the
          value until it reaches 0. The DPSM then moves to the Idle
          state and when there has been no error, the data status
          end flag (DATAEND) is set.</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATACOUNT</name>
              <description>Data count value When read, the number
              of remaining data bytes to be transferred is
              returned. Write has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STAR</name>
          <displayName>SDMMC_STAR</displayName>
          <description>The SDMMC_STAR register is a read-only
          register. It contains two types of flag:Static flags
          (bits [29,21,11:0]): these bits remain asserted until
          they are cleared by writing to the SDMMC interrupt Clear
          register (see SDMMC_ICR)Dynamic flags (bits [20:12]):
          these bits change state depending on the state of the
          underlying logic (for example, FIFO full and empty flags
          are asserted and de-asserted as data while written to the
          FIFO)</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABTC</name>
              <description>IDMA buffer transfer complete. interrupt
              flag is cleared by writing corresponding interrupt
              clear bit in SDMMC_ICR.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDMATE</name>
              <description>IDMA transfer error. Interrupt flag is
              cleared by writing corresponding interrupt clear bit
              in SDMMC_ICR.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKSTOP</name>
              <description>SDMMC_CK stopped in Voltage switch
              procedure. Interrupt flag is cleared by writing
              corresponding interrupt clear bit in
              SDMMC_ICR.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSWEND</name>
              <description>Voltage switch critical timing section
              completion. Interrupt flag is cleared by writing
              corresponding interrupt clear bit in
              SDMMC_ICR.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKTIMEOUT</name>
              <description>Boot acknowledgment timeout. Interrupt
              flag is cleared by writing corresponding interrupt
              clear bit in SDMMC_ICR.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKFAIL</name>
              <description>Boot acknowledgment received (boot
              acknowledgment check fail). Interrupt flag is cleared
              by writing corresponding interrupt clear bit in
              SDMMC_ICR.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIOIT</name>
              <description>SDIO interrupt received. Interrupt flag
              is cleared by writing corresponding interrupt clear
              bit in SDMMC_ICR.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSYD0END</name>
              <description>end of SDMMC_D0 Busy following a CMD
              response detected. This indicates only end of busy
              following a CMD response. This bit does not signal
              busy due to data transfer. Interrupt flag is cleared
              by writing corresponding interrupt clear bit in
              SDMMC_ICR.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSYD0</name>
              <description>Inverted value of SDMMC_D0 line (Busy),
              sampled at the end of a CMD response and a second
              time 2 SDMMC_CK cycles after the CMD response. This
              bit is reset to not busy when the SDMMCD0 line
              changes from busy to not busy. This bit does not
              signal busy due to data transfer. This is a hardware
              status flag only, it does not generate an
              interrupt.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFOE</name>
              <description>Receive FIFO empty This is a hardware
              status flag only, does not generate an interrupt.
              This bit is cleared when one FIFO location becomes
              full.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFOE</name>
              <description>Transmit FIFO empty This bit is cleared
              when one FIFO location becomes full.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFOF</name>
              <description>Receive FIFO full This bit is cleared
              when one FIFO location becomes empty.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFOF</name>
              <description>Transmit FIFO full This is a hardware
              status flag only, does not generate an interrupt.
              This bit is cleared when one FIFO location becomes
              empty.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFOHF</name>
              <description>Receive FIFO half full There are at
              least half the number of words in the FIFO. This bit
              is cleared when the FIFO becomes half+1
              empty.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFOHE</name>
              <description>Transmit FIFO half empty At least half
              the number of words can be written into the FIFO.
              This bit is cleared when the FIFO becomes half+1
              full.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CPSMACT</name>
              <description>Command path state machine active, i.e.
              not in Idle state. This is a hardware status flag
              only, does not generate an interrupt.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPSMACT</name>
              <description>Data path state machine active, i.e. not
              in Idle state. This is a hardware status flag only,
              does not generate an interrupt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DABORT</name>
              <description>Data transfer aborted by CMD12.
              Interrupt flag is cleared by writing corresponding
              interrupt clear bit in SDMMC_ICR.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBCKEND</name>
              <description>Data block sent/received (CRC check
              passed)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DHOLD</name>
              <description>Data transfer Hold. Interrupt flag is
              cleared by writing corresponding interrupt clear bit
              in SDMMC_ICR.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATAEND</name>
              <description>Data transfer ended correctly. (data
              counter, DATACOUNT is zero and no errors occur).
              Interrupt flag is cleared by writing corresponding
              interrupt clear bit in SDMMC_ICR.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDSENT</name>
              <description>Command sent (no response
              required)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDREND</name>
              <description>Command response received (CRC check
              passed)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXOVERR</name>
              <description>Received FIFO overrun
              error</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXUNDERR</name>
              <description>Transmit FIFO underrun
              error</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTIMEOUT</name>
              <description>Data timeout</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIMEOUT</name>
              <description>Command response timeout</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCFAIL</name>
              <description>Data block sent/received (CRC check
              failed)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCFAIL</name>
              <description>Command response received (CRC check
              failed)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>interrupt clear register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABTCC</name>
              <description>IDMA buffer transfer complete clear bit
              Set by software to clear the IDMABTC
              flag.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDMATEC</name>
              <description>IDMA transfer error clear bit Set by
              software to clear the IDMATE flag.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKSTOPC</name>
              <description>CKSTOP flag clear bit Set by software to
              clear the CKSTOP flag.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSWENDC</name>
              <description>VSWEND flag clear bit Set by software to
              clear the VSWEND flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKTIMEOUTC</name>
              <description>ACKTIMEOUT flag clear bit Set by
              software to clear the ACKTIMEOUT flag.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKFAILC</name>
              <description>ACKFAIL flag clear bit Set by software
              to clear the ACKFAIL flag.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIOITC</name>
              <description>SDIOIT flag clear bit</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSYD0ENDC</name>
              <description>BUSYD0END flag clear bit Set by software
              to clear the BUSYD0END flag.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DABORTC</name>
              <description>DABORT flag clear bit Set by software to
              clear the DABORT flag.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBCKENDC</name>
              <description>DBCKEND flag clear bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DHOLDC</name>
              <description>DHOLD flag clear bit Set by software to
              clear the DHOLD flag.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATAENDC</name>
              <description>DATAEND flag clear bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDSENTC</name>
              <description>CMDSENT flag clear bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDRENDC</name>
              <description>CMDREND flag clear bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXOVERRC</name>
              <description>RXOVERR flag clear bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXUNDERRC</name>
              <description>TXUNDERR flag clear bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTIMEOUTC</name>
              <description>DTIMEOUT flag clear bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIMEOUTC</name>
              <description>CTIMEOUT flag clear bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCFAILC</name>
              <description>DCRCFAIL flag clear bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCFAILC</name>
              <description>CCRCFAIL flag clear bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MASKR</name>
          <displayName>SDMMC_MASKR</displayName>
          <description>The interrupt mask register determines which
          status flags generate an interrupt request by setting the
          corresponding bit to 1.</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABTCIE</name>
              <description>IDMA buffer transfer complete interrupt
              enable Set and cleared by software to enable/disable
              the interrupt generated when the IDMA has transferred
              all data belonging to a memory buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKSTOPIE</name>
              <description>Voltage Switch clock stopped interrupt
              enable Set and cleared by software to enable/disable
              interrupt caused by Voltage Switch clock
              stopped.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSWENDIE</name>
              <description>Voltage switch critical timing section
              completion interrupt enable Set and cleared by
              software to enable/disable the interrupt generated
              when voltage switch critical timing section
              completion.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKTIMEOUTIE</name>
              <description>Acknowledgment timeout interrupt enable
              Set and cleared by software to enable/disable
              interrupt caused by acknowledgment
              timeout.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACKFAILIE</name>
              <description>Acknowledgment Fail interrupt enable Set
              and cleared by software to enable/disable interrupt
              caused by acknowledgment Fail.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIOITIE</name>
              <description>SDIO mode interrupt received interrupt
              enable Set and cleared by software to enable/disable
              the interrupt generated when receiving the SDIO mode
              interrupt.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSYD0ENDIE</name>
              <description>BUSYD0END interrupt enable Set and
              cleared by software to enable/disable the interrupt
              generated when SDMMC_D0 signal changes from busy to
              NOT busy following a CMD response.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFOEIE</name>
              <description>Tx FIFO empty interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by Tx FIFO empty.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFOFIE</name>
              <description>Rx FIFO full interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by Rx FIFO full.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFOHFIE</name>
              <description>Rx FIFO half full interrupt enable Set
              and cleared by software to enable/disable interrupt
              caused by Rx FIFO half full.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFOHEIE</name>
              <description>Tx FIFO half empty interrupt enable Set
              and cleared by software to enable/disable interrupt
              caused by Tx FIFO half empty.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DABORTIE</name>
              <description>Data transfer aborted interrupt enable
              Set and cleared by software to enable/disable
              interrupt caused by a data transfer being
              aborted.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBCKENDIE</name>
              <description>Data block end interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by data block end.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DHOLDIE</name>
              <description>Data hold interrupt enable Set and
              cleared by software to enable/disable the interrupt
              generated when sending new data is hold in the DPSM
              Wait_S state.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATAENDIE</name>
              <description>Data end interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by data end.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDSENTIE</name>
              <description>Command sent interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by sending command.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDRENDIE</name>
              <description>Command response received interrupt
              enable Set and cleared by software to enable/disable
              interrupt caused by receiving command
              response.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXOVERRIE</name>
              <description>Rx FIFO overrun error interrupt enable
              Set and cleared by software to enable/disable
              interrupt caused by Rx FIFO overrun
              error.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXUNDERRIE</name>
              <description>Tx FIFO underrun error interrupt enable
              Set and cleared by software to enable/disable
              interrupt caused by Tx FIFO underrun
              error.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTIMEOUTIE</name>
              <description>Data timeout interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by data timeout.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIMEOUTIE</name>
              <description>Command timeout interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by command timeout.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCFAILIE</name>
              <description>Data CRC fail interrupt enable Set and
              cleared by software to enable/disable interrupt
              caused by data CRC failure.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCFAILIE</name>
              <description>Command CRC fail interrupt enable Set
              and cleared by software to enable/disable interrupt
              caused by command CRC failure.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACKTIMER</name>
          <displayName>SDMMC_ACKTIMER</displayName>
          <description>The SDMMC_ACKTIMER register contains the
          acknowledgment timeout period, in SDMMC_CK bus clock
          periods. A counter loads the value from the
          SDMMC_ACKTIMER register, and starts decrementing when the
          data path state machine (DPSM) enters the Wait_Ack state.
          If the timer reaches 0 while the DPSM is in this states,
          the acknowledgment timeout status flag is
          set.</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ACKTIME</name>
              <description>Boot acknowledgment timeout period This
              bit can only be written by firmware when CPSM is
              disabled (CPSMEN = 0). Boot acknowledgment timeout
              period expressed in card bus clock
              periods.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDMACTRLR</name>
          <displayName>SDMMC_IDMACTRLR</displayName>
          <description>The receive and transmit FIFOs can be read
          or written as 32-bit wide registers. The FIFOs contain 32
          entries on 32 sequential addresses. This allows the CPU
          to use its load and store multiple operands to read
          from/write to the FIFO.</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABACT</name>
              <description>Double buffer mode active buffer
              indication This bit can only be written by firmware
              when DPSM is inactive (DPSMACT = 0). When IDMA is
              enabled this bit is toggled by
              hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDMABMODE</name>
              <description>Buffer mode selection. This bit can only
              be written by firmware when DPSM is inactive (DPSMACT
              = 0).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDMAEN</name>
              <description>IDMA enable This bit can only be written
              by firmware when DPSM is inactive (DPSMACT =
              0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDMABSIZER</name>
          <displayName>SDMMC_IDMABSIZER</displayName>
          <description>The SDMMC_IDMABSIZER register contains the
          buffers size when in double buffer
          configuration.</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABNDT</name>
              <description>Number of transfers per buffer. This
              8-bit value shall be multiplied by 8 to get the size
              of the buffer in 32-bit words and by 32 to get the
              size of the buffer in bytes. Example: IDMABNDT =
              0x01: buffer size = 8 words = 32 bytes. These bits
              can only be written by firmware when DPSM is inactive
              (DPSMACT = 0).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDMABASE0R</name>
          <displayName>SDMMC_IDMABASE0R</displayName>
          <description>The SDMMC_IDMABASE0R register contains the
          memory buffer base address in single buffer configuration
          and the buffer 0 base address in double buffer
          configuration.</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABASE0</name>
              <description>Buffer 0 memory base address bits
              [31:2], shall be word aligned (bit [1:0] are always 0
              and read only). This register can be written by
              firmware when DPSM is inactive (DPSMACT = 0), and can
              dynamically be written by firmware when DPSM active
              (DPSMACT = 1) and memory buffer 0 is inactive
              (IDMABACT = 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_IDMABASE1R</name>
          <displayName>SDMMC_IDMABASE1R</displayName>
          <description>The SDMMC_IDMABASE1R register contains the
          double buffer configuration second buffer memory base
          address.</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDMABASE1</name>
              <description>Buffer 1 memory base address, shall be
              word aligned (bit [1:0] are always 0 and read only).
              This register can be written by firmware when DPSM is
              inactive (DPSMACT = 0), and can dynamically be
              written by firmware when DPSM active (DPSMACT = 1)
              and memory buffer 1 is inactive (IDMABACT =
              0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESPCMDR</name>
          <displayName>SDMMC_RESPCMDR</displayName>
          <description>The SDMMC_RESPCMDR register contains the
          command index field of the last command response
          received. If the command response transmission does not
          contain the command index field (long or OCR response),
          the RESPCMD field is unknown, although it must contain
          111111b (the value of the reserved field from the
          response).</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESPCMD</name>
              <description>Response command index Read-only bit
              field. Contains the command index of the last command
              response received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FIFOR</name>
          <displayName>SDMMC_FIFOR</displayName>
          <description>The receive and transmit FIFOs can be only
          read or written as word (32-bit) wide registers. The
          FIFOs contain 16 entries on sequential addresses. This
          allows the CPU to use its load and store multiple
          operands to read from/write to the FIFO.When accessing
          SDMMC_FIFOR with half word or byte access an AHB bus
          fault is generated.</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIFODATA</name>
              <description>Receive and transmit FIFO data This
              register can only be read or written by firmware when
              the DPSM is active (DPSMACT=1). The FIFO data
              occupies 16 entries of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_VER</name>
          <displayName>SDMMC_VER</displayName>
          <description>SDMMC IP version register</description>
          <addressOffset>0x3F4</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>MAJREV</name>
              <description>IP major revision number.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MINREV</name>
              <description>IP minor revision number.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ID</name>
          <displayName>SDMMC_ID</displayName>
          <description>SDMMC IP identification
          register</description>
          <addressOffset>0x3F8</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00140022</resetValue>
          <fields>
            <field>
              <name>IP_ID</name>
              <description>SDMMC IP identification.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    